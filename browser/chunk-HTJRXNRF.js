import{a as M,b as C}from"./chunk-EU62SVTO.js";import{g as c,h,i as _,j as a,k as w}from"./chunk-VE22RIJ6.js";import{a as d}from"./chunk-XXSLHR3E.js";import{a as l}from"./chunk-3WG2WLZ4.js";import{b as P}from"./chunk-4UCLQGBG.js";var p=(()=>{class i{constructor(r){this.value=this._toInt(r)}_toInt(r){return r|0}add(r){return new i(this.value+r.value)}subtract(r){return new i(this.value-r.value)}multiply(r){return new i(Math.imul(this.value,r.value))}divide(r){return new i(this.value/r.value)}getClassName(){return i.ClassName}equals(r){return this.value===r.value}static FromValue(r){return new i(r)}toString(){return this.value.toString()}}return i.ClassName="FlowGraphInteger",i})();l("FlowGraphInteger",p);var m=class i{constructor(t=[1,0,0,1]){this._m=t}get m(){return this._m}transformVector(t){return this.transformVectorToRef(t,new c)}transformVectorToRef(t,r){return r.x=t.x*this._m[0]+t.y*this._m[1],r.y=t.x*this._m[2]+t.y*this._m[3],r}asArray(){return this.toArray()}toArray(t=[]){for(let r=0;r<4;r++)t[r]=this._m[r];return t}fromArray(t){for(let r=0;r<4;r++)this._m[r]=t[r];return this}multiplyToRef(t,r){let e=t._m,n=this._m,o=r._m;return o[0]=e[0]*n[0]+e[1]*n[2],o[1]=e[0]*n[1]+e[1]*n[3],o[2]=e[2]*n[0]+e[3]*n[2],o[3]=e[2]*n[1]+e[3]*n[3],r}multiply(t){return this.multiplyToRef(t,new i)}divideToRef(t,r){let e=this._m,n=t._m,o=r._m;return o[0]=e[0]/n[0],o[1]=e[1]/n[1],o[2]=e[2]/n[2],o[3]=e[3]/n[3],r}divide(t){return this.divideToRef(t,new i)}addToRef(t,r){let e=this._m,n=t.m,o=r.m;return o[0]=e[0]+n[0],o[1]=e[1]+n[1],o[2]=e[2]+n[2],o[3]=e[3]+n[3],r}add(t){return this.addToRef(t,new i)}subtractToRef(t,r){let e=this._m,n=t.m,o=r.m;return o[0]=e[0]-n[0],o[1]=e[1]-n[1],o[2]=e[2]-n[2],o[3]=e[3]-n[3],r}subtract(t){return this.subtractToRef(t,new i)}transpose(){let t=this._m;return new i([t[0],t[2],t[1],t[3]])}determinant(){let t=this._m;return t[0]*t[3]-t[1]*t[2]}inverse(){let t=this.determinant();if(t===0)throw new Error("Matrix is not invertible");let r=this._m,e=1/t;return new i([r[3]*e,-r[1]*e,-r[2]*e,r[0]*e])}equals(t,r=0){let e=this._m,n=t.m;return r===0?e[0]===n[0]&&e[1]===n[1]&&e[2]===n[2]&&e[3]===n[3]:Math.abs(e[0]-n[0])<r&&Math.abs(e[1]-n[1])<r&&Math.abs(e[2]-n[2])<r&&Math.abs(e[3]-n[3])<r}getClassName(){return"FlowGraphMatrix2D"}toString(){return`FlowGraphMatrix2D(${this._m.join(", ")})`}},f=class i{constructor(t=[1,0,0,0,1,0,0,0,1]){this._m=t}get m(){return this._m}transformVector(t){return this.transformVectorToRef(t,new h)}transformVectorToRef(t,r){let e=this._m;return r.x=t.x*e[0]+t.y*e[1]+t.z*e[2],r.y=t.x*e[3]+t.y*e[4]+t.z*e[5],r.z=t.x*e[6]+t.y*e[7]+t.z*e[8],r}multiplyToRef(t,r){let e=t._m,n=this._m,o=r.m;return o[0]=e[0]*n[0]+e[1]*n[3]+e[2]*n[6],o[1]=e[0]*n[1]+e[1]*n[4]+e[2]*n[7],o[2]=e[0]*n[2]+e[1]*n[5]+e[2]*n[8],o[3]=e[3]*n[0]+e[4]*n[3]+e[5]*n[6],o[4]=e[3]*n[1]+e[4]*n[4]+e[5]*n[7],o[5]=e[3]*n[2]+e[4]*n[5]+e[5]*n[8],o[6]=e[6]*n[0]+e[7]*n[3]+e[8]*n[6],o[7]=e[6]*n[1]+e[7]*n[4]+e[8]*n[7],o[8]=e[6]*n[2]+e[7]*n[5]+e[8]*n[8],r}multiply(t){return this.multiplyToRef(t,new i)}divideToRef(t,r){let e=this._m,n=t.m,o=r.m;return o[0]=e[0]/n[0],o[1]=e[1]/n[1],o[2]=e[2]/n[2],o[3]=e[3]/n[3],o[4]=e[4]/n[4],o[5]=e[5]/n[5],o[6]=e[6]/n[6],o[7]=e[7]/n[7],o[8]=e[8]/n[8],r}divide(t){return this.divideToRef(t,new i)}addToRef(t,r){let e=this._m,n=t.m,o=r.m;return o[0]=e[0]+n[0],o[1]=e[1]+n[1],o[2]=e[2]+n[2],o[3]=e[3]+n[3],o[4]=e[4]+n[4],o[5]=e[5]+n[5],o[6]=e[6]+n[6],o[7]=e[7]+n[7],o[8]=e[8]+n[8],r}add(t){return this.addToRef(t,new i)}subtractToRef(t,r){let e=this._m,n=t.m,o=r.m;return o[0]=e[0]-n[0],o[1]=e[1]-n[1],o[2]=e[2]-n[2],o[3]=e[3]-n[3],o[4]=e[4]-n[4],o[5]=e[5]-n[5],o[6]=e[6]-n[6],o[7]=e[7]-n[7],o[8]=e[8]-n[8],r}subtract(t){return this.subtractToRef(t,new i)}toArray(t=[]){for(let r=0;r<9;r++)t[r]=this._m[r];return t}asArray(){return this.toArray()}fromArray(t){for(let r=0;r<9;r++)this._m[r]=t[r];return this}transpose(){let t=this._m;return new i([t[0],t[3],t[6],t[1],t[4],t[7],t[2],t[5],t[8]])}determinant(){let t=this._m;return t[0]*(t[4]*t[8]-t[5]*t[7])-t[1]*(t[3]*t[8]-t[5]*t[6])+t[2]*(t[3]*t[7]-t[4]*t[6])}inverse(){let t=this.determinant();if(t===0)throw new Error("Matrix is not invertible");let r=this._m,e=1/t;return new i([(r[4]*r[8]-r[5]*r[7])*e,(r[2]*r[7]-r[1]*r[8])*e,(r[1]*r[5]-r[2]*r[4])*e,(r[5]*r[6]-r[3]*r[8])*e,(r[0]*r[8]-r[2]*r[6])*e,(r[2]*r[3]-r[0]*r[5])*e,(r[3]*r[7]-r[4]*r[6])*e,(r[1]*r[6]-r[0]*r[7])*e,(r[0]*r[4]-r[1]*r[3])*e])}equals(t,r=0){let e=this._m,n=t.m;return r===0?e[0]===n[0]&&e[1]===n[1]&&e[2]===n[2]&&e[3]===n[3]&&e[4]===n[4]&&e[5]===n[5]&&e[6]===n[6]&&e[7]===n[7]&&e[8]===n[8]:Math.abs(e[0]-n[0])<r&&Math.abs(e[1]-n[1])<r&&Math.abs(e[2]-n[2])<r&&Math.abs(e[3]-n[3])<r&&Math.abs(e[4]-n[4])<r&&Math.abs(e[5]-n[5])<r&&Math.abs(e[6]-n[6])<r&&Math.abs(e[7]-n[7])<r&&Math.abs(e[8]-n[8])<r}getClassName(){return"FlowGraphMatrix3D"}toString(){return`FlowGraphMatrix3D(${this._m.join(", ")})`}};var s=class{constructor(t,r,e=-1){this.typeName=t,this.defaultValue=r,this.animationType=e}serialize(t){t.typeName=this.typeName,t.defaultValue=this.defaultValue}},g=new s("any",void 0),F=new s("string",""),T=new s("number",0,0),q=new s("boolean",!1),I=new s("Vector2",c.Zero(),5),D=new s("Vector3",h.Zero(),1),N=new s("Vector4",_.Zero()),R=new s("Matrix",w.Identity(),3),S=new s("Matrix2D",new m),B=new s("Matrix3D",new f),b=new s("Color3",M.Black(),4),A=new s("Color4",new C(0,0,0,0),7),x=new s("Quaternion",a.Identity(),2);x.typeTransformer=i=>i.getClassName&&i.getClassName()==="Vector4"?a.FromArray(i.asArray()):i.getClassName&&i.getClassName()==="Vector3"?a.FromEulerVector(i):i.getClassName&&i.getClassName()==="Matrix"?a.FromRotationMatrix(i):i;var G=new s("FlowGraphInteger",new p(0),0);function Y(i){let t=i;switch(typeof i){case"string":return F;case"number":return T;case"boolean":return q;case"object":if(t.getClassName)switch(t.getClassName()){case"Vector2":return I;case"Vector3":return D;case"Vector4":return N;case"Matrix":return R;case"Color3":return b;case"Color4":return A;case"Quaternion":return x;case"FlowGraphInteger":return G;case"Matrix2D":return S;case"Matrix3D":return B}return g;default:return g}}function k(i){switch(i){case"string":return F;case"number":return T;case"boolean":return q;case"Vector2":return I;case"Vector3":return D;case"Vector4":return N;case"Matrix":return R;case"Color3":return b;case"Color4":return A;case"Quaternion":return x;case"FlowGraphInteger":return G;case"Matrix2D":return S;case"Matrix3D":return B;default:return g}}function H(i){switch(i){case 0:return T;case 5:return I;case 1:return D;case 3:return R;case 4:return b;case 7:return A;case 2:return x;default:return g}}function L(i){return i==="Vector2"||i==="Vector3"||i==="Vector4"||i==="Quaternion"||i==="Color3"||i==="Color4"}function $(i){return i==="Matrix"||i==="Matrix2D"||i==="Matrix3D"}function V(i,t,r){let e=t?.getClassName?.()??"";if(L(e)||$(e))r[i]={value:t.asArray(),className:e};else if(e==="FlowGraphInteger")r[i]={value:t.value,className:e};else if(e&&(t.id||t.name))r[i]={id:t.id,name:t.name,className:e};else if(typeof t!="object")r[i]=t;else throw new Error(`Could not serialize value ${t}`)}var y=class{constructor(t,r,e){this._ownerBlock=e,this._connectedPoint=[],this.uniqueId=d(),this.connectedPointIds=[],this.name=t,this._connectionType=r}get connectionType(){return this._connectionType}_isSingularConnection(){return!0}isConnected(){return this._connectedPoint.length>0}connectTo(t){if(this._connectionType===t._connectionType)throw new Error(`Cannot connect two points of type ${this.connectionType}`);if(this._isSingularConnection()&&this._connectedPoint.length>0||t._isSingularConnection()&&t._connectedPoint.length>0)throw new Error("Max number of connections for point reached");this._connectedPoint.push(t),t._connectedPoint.push(this)}disconnectFrom(t,r=!0){let e=this._connectedPoint.indexOf(t),n=t._connectedPoint.indexOf(this);e===-1||n===-1||(r&&this._connectedPoint.splice(e,1),t._connectedPoint.splice(n,1))}disconnectFromAll(){for(let t of this._connectedPoint)this.disconnectFrom(t,!1);this._connectedPoint.length=0}dispose(){for(let t of this._connectedPoint)this.disconnectFrom(t)}serialize(t={}){t.uniqueId=this.uniqueId,t.name=this.name,t._connectionType=this._connectionType,t.connectedPointIds=[],t.className=this.getClassName();for(let r of this._connectedPoint)t.connectedPointIds.push(r.uniqueId)}getClassName(){return"FGConnection"}deserialize(t){this.uniqueId=t.uniqueId,this.name=t.name,this._connectionType=t._connectionType,this.connectedPointIds=t.connectedPointIds}};var u=class extends y{constructor(t,r,e,n,o=n.defaultValue,E=!1){super(t,r,e),this.richType=n,this._defaultValue=o,this._optional=E,this._isDisabled=!1,this._lastValue=null,this.dataTransformer=null,this.onValueChangedObservable=new P}get optional(){return this._optional}get isDisabled(){return this._isDisabled}set isDisabled(t){this._isDisabled!==t&&(this._isDisabled=t,this._isDisabled&&this.disconnectFromAll())}_isSingularConnection(){return this.connectionType===0}setValue(t,r){r._getConnectionValue(this)!==t&&(r._setConnectionValue(this,t),this.onValueChangedObservable.notifyObservers(t))}resetToDefaultValue(t){t._setConnectionValue(this,this._defaultValue)}connectTo(t){this._isDisabled||super.connectTo(t)}_getValueOrDefault(t){let r=t._getConnectionValue(this)??this._defaultValue;return this.dataTransformer?this.dataTransformer(r):r}getValue(t){if(this.connectionType===1){t._notifyExecuteNode(this._ownerBlock),this._ownerBlock._updateOutputs(t);let e=this._getValueOrDefault(t);return this._lastValue=e,this.richType.typeTransformer?this.richType.typeTransformer(e):e}let r=this.isConnected()?this._connectedPoint[0].getValue(t):this._getValueOrDefault(t);return this._lastValue=r,this.richType.typeTransformer?this.richType.typeTransformer(r):r}_getLastValue(){return this._lastValue}getClassName(){return"FlowGraphDataConnection"}serialize(t={}){super.serialize(t),t.richType={},this.richType.serialize(t.richType),t.optional=this._optional,V("defaultValue",this._defaultValue,t)}};l("FlowGraphDataConnection",u);var Q=class{constructor(t){this.config=t,this.uniqueId=d(),this.name=this.config?.name??this.getClassName(),this.dataInputs=[],this.dataOutputs=[]}_updateOutputs(t){}registerDataInput(t,r,e){let n=new u(t,0,this,r,e);return this.dataInputs.push(n),n}registerDataOutput(t,r,e){let n=new u(t,1,this,r,e);return this.dataOutputs.push(n),n}getDataInput(t){return this.dataInputs.find(r=>r.name===t)}getDataOutput(t){return this.dataOutputs.find(r=>r.name===t)}serialize(t={},r=V){if(t.uniqueId=this.uniqueId,t.config={},this.config){let e=this.config,n=Object.keys(e);for(let o of n)r(o,e[o],t.config)}t.dataInputs=[],t.dataOutputs=[],t.className=this.getClassName();for(let e of this.dataInputs){let n={};e.serialize(n),t.dataInputs.push(n)}for(let e of this.dataOutputs){let n={};e.serialize(n),t.dataOutputs.push(n)}}deserialize(t){}_log(t,r,e){t.logger?.addLogItem({action:r,payload:e,className:this.getClassName(),uniqueId:this.uniqueId})}getClassName(){return"FlowGraphBlock"}};export{p as a,m as b,f as c,g as d,F as e,T as f,q as g,I as h,D as i,N as j,R as k,S as l,B as m,x as n,G as o,Y as p,k as q,H as r,V as s,y as t,Q as u};
