import{a as R,b as C}from"./chunk-DOP7KVFJ.js";import{a as F}from"./chunk-2LR3BD57.js";import{d as w}from"./chunk-XV6OCBTX.js";import{b as E}from"./chunk-L4FK2AOJ.js";import{a as T,d as S}from"./chunk-6LMVZKMZ.js";import{h as g}from"./chunk-4QVQQIPQ.js";import{f as p}from"./chunk-C4D4KATR.js";import{a as N}from"./chunk-3WG2WLZ4.js";import{B as v,l as x}from"./chunk-OQPKOFQF.js";import{a as B}from"./chunk-PTJ4CXVK.js";import{a as y}from"./chunk-L3UYHT7M.js";import{a as M,h as c}from"./chunk-YMYK7FOB.js";var I=class{constructor(){this._gpuTimeInFrameId=-1,this.counter=new F}_addDuration(e,t){e<this._gpuTimeInFrameId||(this._gpuTimeInFrameId!==e?(this.counter._fetchResult(),this.counter.fetchNewFrame(),this.counter.addCount(t,!1),this._gpuTimeInFrameId=e):this.counter.addCount(t,!1))}};var l=class d{get options(){return this._options}get shaderPath(){return this._shaderPath}constructor(e,t,r,i={}){if(this._bindings={},this._samplers={},this._contextIsDirty=!1,this.fastMode=!1,this.onCompiled=null,this.onError=null,this.name=e,this._engine=t,this.uniqueId=C.UniqueId,t.enableGPUTimingMeasurements&&(this.gpuTimeInFrame=new I),!this._engine.getCaps().supportComputeShaders){B.Error("This engine does not support compute shaders!");return}if(!i.bindingsMapping){B.Error("You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!");return}this._context=t.createComputeContext(),this._shaderPath=r,this._options=M({bindingsMapping:{},defines:[]},i)}getClassName(){return"ComputeShader"}setTexture(e,t,r=!0){let i=this._bindings[e];this._bindings[e]={type:r?0:4,object:t,indexInGroupEntries:i?.indexInGroupEntries},this._contextIsDirty||(this._contextIsDirty=!i||i.object!==t||i.type!==this._bindings[e].type)}setStorageTexture(e,t){let r=this._bindings[e];this._contextIsDirty||(this._contextIsDirty=!r||r.object!==t),this._bindings[e]={type:1,object:t,indexInGroupEntries:r?.indexInGroupEntries}}setExternalTexture(e,t){let r=this._bindings[e];this._contextIsDirty||(this._contextIsDirty=!r||r.object!==t),this._bindings[e]={type:6,object:t,indexInGroupEntries:r?.indexInGroupEntries}}setVideoTexture(e,t){return t.externalTexture?(this.setExternalTexture(e,t.externalTexture),!0):!1}setUniformBuffer(e,t){let r=this._bindings[e];this._contextIsDirty||(this._contextIsDirty=!r||r.object!==t),this._bindings[e]={type:d._BufferIsDataBuffer(t)?7:2,object:t,indexInGroupEntries:r?.indexInGroupEntries}}setStorageBuffer(e,t){let r=this._bindings[e];this._contextIsDirty||(this._contextIsDirty=!r||r.object!==t),this._bindings[e]={type:d._BufferIsDataBuffer(t)?7:3,object:t,indexInGroupEntries:r?.indexInGroupEntries}}setTextureSampler(e,t){let r=this._bindings[e];this._contextIsDirty||(this._contextIsDirty=!r||!t.compareSampler(r.object)),this._bindings[e]={type:5,object:t,indexInGroupEntries:r?.indexInGroupEntries}}isReady(){let e=this._effect;for(let s in this._bindings){let n=this._bindings[s],a=n.type,u=n.object;switch(a){case 0:case 4:case 1:{if(!u.isReady())return!1;break}case 6:{if(!u.isReady())return!1;break}}}let t=[],r=this._shaderPath;if(this._options.defines)for(let s=0;s<this._options.defines.length;s++)t.push(this._options.defines[s]);let i=t.join(`
`);return this._cachedDefines!==i&&(this._cachedDefines=i,e=this._engine.createComputeEffect(r,{defines:i,entryPoint:this._options.entryPoint,onCompiled:this.onCompiled,onError:this.onError}),this._effect=e),!!e.isReady()}dispatch(e,t,r){return!this.fastMode&&!this._checkContext()?!1:(this._engine.computeDispatch(this._effect,this._context,this._bindings,e,t,r,this._options.bindingsMapping,this.gpuTimeInFrame),!0)}dispatchIndirect(e,t=0){if(!this.fastMode&&!this._checkContext())return!1;let r=d._BufferIsDataBuffer(e)?e:e.getBuffer();return this._engine.computeDispatchIndirect(this._effect,this._context,this._bindings,r,t,this._options.bindingsMapping,this.gpuTimeInFrame),!0}_checkContext(){if(!this.isReady())return!1;for(let e in this._bindings){let t=this._bindings[e];if(!this._options.bindingsMapping[e])throw new Error("ComputeShader ('"+this.name+"'): No binding mapping has been provided for the property '"+e+"'");switch(t.type){case 0:{let r=this._samplers[e],i=t.object;(!r||!i._texture||!r.compareSampler(i._texture))&&(this._samplers[e]=new v().setParameters(i.wrapU,i.wrapV,i.wrapR,i.anisotropicFilteringLevel,i._texture.samplingMode,i._texture?._comparisonFunction),this._contextIsDirty=!0);break}case 6:{this._contextIsDirty=!0;break}case 2:{let r=t.object;r.getBuffer()!==t.buffer&&(t.buffer=r.getBuffer(),this._contextIsDirty=!0);break}}}return this._contextIsDirty&&(this._contextIsDirty=!1,this._context.clear()),!0}dispatchWhenReady(e,t,r,i=10){return c(this,null,function*(){return yield new Promise(s=>{x(()=>this.dispatch(e,t,r),s,void 0,i)})})}serialize(){let e=E.Serialize(this);e.options=this._options,e.shaderPath=this._shaderPath,e.bindings={},e.textures={};for(let t in this._bindings){let r=this._bindings[t],i=r.object;switch(r.type){case 0:case 4:case 1:{let s=i.serialize();s&&(e.textures[t]=s,e.bindings[t]={type:r.type});break}case 2:break}}return e}static Parse(e,t,r){let i=E.Parse(()=>new d(e.name,t.getEngine(),e.shaderPath,e.options),e,t,r);for(let s in e.textures){let n=e.bindings[s],a=w.Parse(e.textures[s],t,r);n.type===0?i.setTexture(s,a):n.type===4?i.setTexture(s,a,!1):i.setStorageTexture(s,a)}return i}static _BufferIsDataBuffer(e){return e.underlyingResource!==void 0}};T([S()],l.prototype,"name",void 0);T([S()],l.prototype,"fastMode",void 0);N("BABYLON.ComputeShader",l);var m=class{constructor(e,t,r=3,i){this._engine=e,this._label=i,this._engine._storageBuffers.push(this),this._create(t,r)}_create(e,t){this._bufferSize=e,this._creationFlags=t,this._buffer=this._engine.createStorageBuffer(e,t,this._label)}_rebuild(){this._create(this._bufferSize,this._creationFlags)}getBuffer(){return this._buffer}update(e,t,r){this._buffer&&this._engine.updateStorageBuffer(this._buffer,e,t,r)}read(e,t,r,i){return c(this,null,function*(){return yield this._engine.readFromStorageBuffer(this._buffer,e,t,r,i)})}dispose(){let e=this._engine._storageBuffers,t=e.indexOf(this);t!==-1&&(e[t]=e[e.length-1],e.pop()),this._engine._releaseBuffer(this._buffer),this._buffer=null}};var L="boundingInfoComputeShader",V=`struct Results {minX : atomic<i32>,
minY : atomic<i32>,
minZ : atomic<i32>,
maxX : atomic<i32>,
maxY : atomic<i32>,
maxZ : atomic<i32>,
dummy1 : i32,
dummy2 : i32,};fn floatToBits(value: f32)->i32 {return bitcast<i32>(value);}
fn bitsToFloat(value: i32)->f32 {return bitcast<f32>(value);}
fn atomicMinFloat(atomicVar: ptr<storage,atomic<i32>,read_write>,value: f32) {let intValue=floatToBits(value);loop {let oldIntValue=atomicLoad(atomicVar);let oldValue=bitsToFloat(oldIntValue);if (value>=oldValue) {break;}
if (atomicCompareExchangeWeak(atomicVar,oldIntValue,intValue).old_value==oldIntValue) {break;}}}
fn atomicMaxFloat(atomicVar: ptr<storage,atomic<i32>,read_write>,value: f32) {let intValue=floatToBits(value);loop {let oldIntValue=atomicLoad(atomicVar);let oldValue=bitsToFloat(oldIntValue);if (value<=oldValue) {break;}
if (atomicCompareExchangeWeak(atomicVar,oldIntValue,intValue).old_value==oldIntValue) {break;}}}
fn readMatrixFromRawSampler(smp : texture_2d<f32>,index : f32)->mat4x4<f32>
{let offset=i32(index) *4; 
let m0=textureLoad(smp,vec2<i32>(offset+0,0),0);let m1=textureLoad(smp,vec2<i32>(offset+1,0),0);let m2=textureLoad(smp,vec2<i32>(offset+2,0),0);let m3=textureLoad(smp,vec2<i32>(offset+3,0),0);return mat4x4<f32>(m0,m1,m2,m3);}
const identity=mat4x4f(
vec4f(1.0,0.0,0.0,0.0),
vec4f(0.0,1.0,0.0,0.0),
vec4f(0.0,0.0,1.0,0.0),
vec4f(0.0,0.0,0.0,1.0)
);struct Settings {morphTargetTextureInfo: vec3f,
morphTargetCount: i32,
indexResult : u32,};@group(0) @binding(0) var<storage,read> positionBuffer : array<f32>;@group(0) @binding(1) var<storage,read_write> resultBuffer : array<Results>;@group(0) @binding(7) var<uniform> settings : Settings;
#if NUM_BONE_INFLUENCERS>0
@group(0) @binding(2) var boneSampler : texture_2d<f32>;@group(0) @binding(3) var<storage,read> indexBuffer : array<vec4f>;@group(0) @binding(4) var<storage,read> weightBuffer : array<vec4f>;
#if NUM_BONE_INFLUENCERS>4
@group(0) @binding(5) var<storage,read> indexExtraBuffer : array<vec4f>;@group(0) @binding(6) var<storage,read> weightExtraBuffer : array<vec4f>;
#endif
#endif
#ifdef MORPHTARGETS
@group(0) @binding(8) var morphTargets : texture_2d_array<f32>;@group(0) @binding(9) var<storage,read> morphTargetInfluences : array<f32>;@group(0) @binding(10) var<storage,read> morphTargetTextureIndices : array<f32>;
#endif
#ifdef MORPHTARGETS
fn readVector3FromRawSampler(targetIndex : i32,vertexIndex : u32)->vec3f
{ 
let vertexID=f32(vertexIndex)*settings.morphTargetTextureInfo.x;let y=floor(vertexID/settings.morphTargetTextureInfo.y);let x=vertexID-y*settings.morphTargetTextureInfo.y;let textureUV=vec2<i32>(i32(x),i32(y));return textureLoad(morphTargets,textureUV,i32(morphTargetTextureIndices[targetIndex]),0).xyz;}
fn readVector4FromRawSampler(targetIndex : i32,vertexIndex : u32)->vec4f
{ 
let vertexID=f32(vertexIndex)*settings.morphTargetTextureInfo.x;let y=floor(vertexID/settings.morphTargetTextureInfo.y);let x=vertexID-y*settings.morphTargetTextureInfo.y;let textureUV=vec2<i32>(i32(x),i32(y));return textureLoad(morphTargets,textureUV,i32(morphTargetTextureIndices[targetIndex]),0);}
#endif
@compute @workgroup_size(256,1,1)
fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {let index=global_id.x;if (index>=arrayLength(&positionBuffer)/3) {return;}
let position=vec3f(positionBuffer[index*3],positionBuffer[index*3+1],positionBuffer[index*3+2]);var finalWorld=identity;var positionUpdated=position;
#if NUM_BONE_INFLUENCERS>0
var influence : mat4x4<f32>;let matricesIndices=indexBuffer[index];let matricesWeights=weightBuffer[index];influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif 
#if NUM_BONE_INFLUENCERS>4
let matricesIndicesExtra=indexExtraBuffer[index];let matricesWeightsExtra=weightExtraBuffer[index];influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.x)*matricesWeightsExtra.x;
#if NUM_BONE_INFLUENCERS>5
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.y)*matricesWeightsExtra.y;
#endif 
#if NUM_BONE_INFLUENCERS>6
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.z)*matricesWeightsExtra.z;
#endif 
#if NUM_BONE_INFLUENCERS>7
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.w)*matricesWeightsExtra.w;
#endif 
#endif 
finalWorld=finalWorld*influence;
#endif
#ifdef MORPHTARGETS
for (var i=0; i<NUM_MORPH_INFLUENCERS; i=i+1) {if (i>=settings.morphTargetCount) {break;}
positionUpdated=positionUpdated+(readVector3FromRawSampler(i,index)-position)*morphTargetInfluences[i];}
#endif
var worldPos=finalWorld*vec4f(positionUpdated.x,positionUpdated.y,positionUpdated.z,1.0);atomicMinFloat(&resultBuffer[settings.indexResult].minX,worldPos.x);atomicMinFloat(&resultBuffer[settings.indexResult].minY,worldPos.y);atomicMinFloat(&resultBuffer[settings.indexResult].minZ,worldPos.z);atomicMaxFloat(&resultBuffer[settings.indexResult].maxX,worldPos.x);atomicMaxFloat(&resultBuffer[settings.indexResult].maxY,worldPos.y);atomicMaxFloat(&resultBuffer[settings.indexResult].maxZ,worldPos.z);}
`;y.ShadersStoreWGSL[L]||(y.ShadersStoreWGSL[L]=V);var D=class{constructor(e){this._computeShadersCache={},this._positionBuffers={},this._indexBuffers={},this._weightBuffers={},this._indexExtraBuffers={},this._weightExtraBuffers={},this._morphTargetInfluenceBuffers={},this._morphTargetTextureIndexBuffers={},this._ubos=[],this._uboIndex=0,this._processedMeshes=[],this._computeShaders=[],this._uniqueComputeShaders=new Set,this._resultBuffers=[],this._engine=e}_getComputeShader(e,t,r){let i,s=e.join(`
`);if(this._computeShadersCache[s])i=this._computeShadersCache[s];else{let n={positionBuffer:{group:0,binding:0},resultBuffer:{group:0,binding:1},settings:{group:0,binding:7}};t&&(n.boneSampler={group:0,binding:2},n.indexBuffer={group:0,binding:3},n.weightBuffer={group:0,binding:4},n.indexExtraBuffer={group:0,binding:5},n.weightExtraBuffer={group:0,binding:6}),r&&(n.morphTargets={group:0,binding:8},n.morphTargetInfluences={group:0,binding:9},n.morphTargetTextureIndices={group:0,binding:10}),i=new l(`boundingInfoCompute${t?"_bones":""}${r?"_morphs":""}`,this._engine,"boundingInfo",{bindingsMapping:n,defines:e}),this._computeShadersCache[s]=i}return i}_getUBO(){if(this._uboIndex>=this._ubos.length){let e=new R(this._engine);e.addFloat3("morphTargetTextureInfo",0,0,0),e.addUniform("morphTargetCount",1),e.addUniform("indexResult",1),this._ubos.push(e)}return this._ubos[this._uboIndex++]}_extractDataAndLink(e,t,r,i,s,n){let a,u=t.getTotalVertices();if(n[t.uniqueId])a=n[t.uniqueId];else{let o=t.getVertexBuffer(r)?.getFloatData(u);a=new m(this._engine,Float32Array.BYTES_PER_ELEMENT*u*i),a.update(o),n[t.uniqueId]=a}e.setStorageBuffer(s,a)}_prepareStorage(e,t,r,i,s,n){let a;i[r]?a=i[r]:(a=new m(this._engine,Float32Array.BYTES_PER_ELEMENT*s),i[r]=a),a.update(n),e.setStorageBuffer(t,a)}processAsync(e){return c(this,null,function*(){yield this.registerMeshListAsync(e),this.processMeshList(),yield this.fetchResultsForMeshListAsync()})}registerMeshListAsync(e){this._disposeForMeshList(),Array.isArray(e)||(e=[e]);let t=0;for(let r=0;r<e.length;r++){let i=e[r];if(i.getTotalVertices()===0||!i.getVertexBuffer||!i.getVertexBuffer(p.PositionKind))continue;this._processedMeshes.push(i);let n=i.morphTargetManager;n&&n.supportsPositions&&(t=Math.max(t,n.numTargets))}for(let r=0;r<this._processedMeshes.length;r++){let i=this._processedMeshes[r],s=[""],n=!1;i&&i.useBones&&i.computeBonesUsingShaders&&i.skeleton&&(s.push("#define NUM_BONE_INFLUENCERS "+i.numBoneInfluencers),n=!0);let a=this._getComputeShader(s,n,!1);this._uniqueComputeShaders.add(a);let u=i.morphTargetManager;if(u&&u.supportsPositions){s=s.slice(),s.push("#define MORPHTARGETS"),s.push("#define NUM_MORPH_INFLUENCERS "+t);let h=this._getComputeShader(s,n,!0);this._uniqueComputeShaders.add(h),this._computeShaders.push([a,h])}else this._computeShaders.push([a,a]);let o=this._getUBO();o.updateUInt("indexResult",r),o.update()}return new Promise(r=>{x(()=>{let i=this._uniqueComputeShaders.keys();for(let s=i.next();s.done!==!0;s=i.next())if(!s.value.isReady())return!1;return!0},r)})}processMeshList(){if(this._processedMeshes.length===0)return;this._uboIndex=0;let e=8*this._processedMeshes.length,t=new Float32Array(e),r=new m(this._engine,Float32Array.BYTES_PER_ELEMENT*e);this._resultBuffers.push(r);for(let i=0;i<this._processedMeshes.length;i++)t[i*8+0]=Number.POSITIVE_INFINITY,t[i*8+1]=Number.POSITIVE_INFINITY,t[i*8+2]=Number.POSITIVE_INFINITY,t[i*8+3]=Number.NEGATIVE_INFINITY,t[i*8+4]=Number.NEGATIVE_INFINITY,t[i*8+5]=Number.NEGATIVE_INFINITY;r.update(t);for(let i=0;i<this._processedMeshes.length;i++){let s=this._processedMeshes[i],n=s.getTotalVertices(),[a,u]=this._computeShaders[i],o=s.morphTargetManager,h=o&&o.numInfluencers>0&&o.supportsPositions,f=h?u:a;if(this._extractDataAndLink(f,s,p.PositionKind,3,"positionBuffer",this._positionBuffers),s&&s.useBones&&s.computeBonesUsingShaders&&s.skeleton&&s.skeleton.useTextureToStoreBoneMatrices){this._extractDataAndLink(f,s,p.MatricesIndicesKind,4,"indexBuffer",this._indexBuffers),this._extractDataAndLink(f,s,p.MatricesWeightsKind,4,"weightBuffer",this._weightBuffers);let b=s.skeleton.getTransformMatrixTexture(s);f.setTexture("boneSampler",b,!1),s.numBoneInfluencers>4&&(this._extractDataAndLink(f,s,p.MatricesIndicesExtraKind,4,"indexExtraBuffer",this._indexExtraBuffers),this._extractDataAndLink(f,s,p.MatricesWeightsExtraKind,4,"weightExtraBuffer",this._weightExtraBuffers))}let _=this._getUBO();if(h){let b=o._targetStoreTexture;f.setTexture("morphTargets",b,!1),this._prepareStorage(f,"morphTargetInfluences",s.uniqueId,this._morphTargetInfluenceBuffers,o.numInfluencers,o.influences),this._prepareStorage(f,"morphTargetTextureIndices",s.uniqueId,this._morphTargetTextureIndexBuffers,o.numInfluencers,o._morphTargetTextureIndices),_.updateFloat3("morphTargetTextureInfo",o._textureVertexStride,o._textureWidth,o._textureHeight),_.updateInt("morphTargetCount",o.numInfluencers),_.update()}f.setStorageBuffer("resultBuffer",r),f.setUniformBuffer("settings",_),f.dispatch(Math.ceil(n/256)),this._engine.flushFramebuffer()}}fetchResultsForMeshListAsync(){return c(this,null,function*(){return yield new Promise(e=>{let t=[],r=0;for(let u=0;u<this._resultBuffers.length;u++){let o=this._resultBuffers[u].getBuffer();t.push(o),r+=o.capacity}let i=new Float32Array(r/Float32Array.BYTES_PER_ELEMENT),s=g.Zero(),n=g.Zero(),a={minimum:s,maximum:n};this._engine.readFromMultipleStorageBuffers(t,0,void 0,i,!0).then(()=>{let u=0;for(let o=0;o<this._resultBuffers.length;o++){for(let h=0;h<this._processedMeshes.length;h++){let f=this._processedMeshes[h];g.FromArrayToRef(i,u+h*8,s),g.FromArrayToRef(i,u+h*8+3,n),o>0&&(s.minimizeInPlace(f.getBoundingInfo().minimum),n.maximizeInPlace(f.getBoundingInfo().maximum)),f._refreshBoundingInfoDirect(a)}u+=8*this._processedMeshes.length}for(let o of this._resultBuffers)o.dispose();this._resultBuffers=[],this._uboIndex=0,e()})})})}_disposeCache(e){for(let t in e)e[t].dispose()}_disposeForMeshList(){for(let e of this._resultBuffers)e.dispose();this._resultBuffers=[],this._processedMeshes=[],this._computeShaders=[],this._uniqueComputeShaders=new Set}dispose(){this._disposeCache(this._positionBuffers),this._positionBuffers={},this._disposeCache(this._indexBuffers),this._indexBuffers={},this._disposeCache(this._weightBuffers),this._weightBuffers={},this._disposeCache(this._morphTargetInfluenceBuffers),this._morphTargetInfluenceBuffers={},this._disposeCache(this._morphTargetTextureIndexBuffers),this._morphTargetTextureIndexBuffers={};for(let e of this._ubos)e.dispose();this._ubos=[],this._computeShadersCache={},this._engine=void 0,this._disposeForMeshList()}};export{m as a,I as b,l as c,D as d};
