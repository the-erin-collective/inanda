import{d as w,g as d,h as u,j as D,k as I}from"./chunk-RMITEGV7.js";import{a as P,f as L}from"./chunk-U26PZYWZ.js";var N=class{static Interpolate(t,s,e,i,a){if(t===0)return 0;let h=1-3*i+3*s,o=3*i-6*s,n=3*s,r=t;for(let c=0;c<5;c++){let l=r*r,p=l*r,g=h*p+o*l+n*r,m=1/(3*h*l+2*o*r+n);r-=(g-t)*m,r=Math.min(1,Math.max(0,r))}return 3*Math.pow(1-r,2)*r*e+3*(1-r)*Math.pow(r,2)*a+Math.pow(r,3)}},A=class _{constructor(t){this._radians=t,this._radians<0&&(this._radians+=2*Math.PI)}degrees(){return this._radians*180/Math.PI}radians(){return this._radians}static BetweenTwoPoints(t,s){let e=s.subtract(t),i=Math.atan2(e.y,e.x);return new _(i)}static BetweenTwoVectors(t,s){let e=t.lengthSquared()*s.lengthSquared();if(e===0)return new _(Math.PI/2);e=Math.sqrt(e);let i=t.dot(s)/e;i=L(i,-1,1);let a=Math.acos(i);return new _(a)}static FromRadians(t){return new _(t)}static FromDegrees(t){return new _(t*Math.PI/180)}},T=class{constructor(t,s,e){this.startPoint=t,this.midPoint=s,this.endPoint=e;let i=Math.pow(s.x,2)+Math.pow(s.y,2),a=(Math.pow(t.x,2)+Math.pow(t.y,2)-i)/2,h=(i-Math.pow(e.x,2)-Math.pow(e.y,2))/2,o=(t.x-s.x)*(s.y-e.y)-(s.x-e.x)*(t.y-s.y);this.centerPoint=new d((a*(s.y-e.y)-h*(t.y-s.y))/o,((t.x-s.x)*h-(s.x-e.x)*a)/o),this.radius=this.centerPoint.subtract(this.startPoint).length(),this.startAngle=A.BetweenTwoPoints(this.centerPoint,this.startPoint);let n=this.startAngle.degrees(),r=A.BetweenTwoPoints(this.centerPoint,this.midPoint).degrees(),c=A.BetweenTwoPoints(this.centerPoint,this.endPoint).degrees();r-n>180&&(r-=360),r-n<-180&&(r+=360),c-r>180&&(c-=360),c-r<-180&&(c+=360),this.orientation=r-n<0?0:1,this.angle=A.FromDegrees(this.orientation===0?n-c:c-n)}},V=class _{constructor(t,s){this._points=new Array,this._length=0,this.closed=!1,this._points.push(new d(t,s))}addLineTo(t,s){if(this.closed)return this;let e=new d(t,s),i=this._points[this._points.length-1];return this._points.push(e),this._length+=e.subtract(i).length(),this}addArcTo(t,s,e,i,a=36){if(this.closed)return this;let h=this._points[this._points.length-1],o=new d(t,s),n=new d(e,i),r=new T(h,o,n),c=r.angle.radians()/a;r.orientation===0&&(c*=-1);let l=r.startAngle.radians()+c;for(let p=0;p<a;p++){let g=Math.cos(l)*r.radius+r.centerPoint.x,m=Math.sin(l)*r.radius+r.centerPoint.y;this.addLineTo(g,m),l+=c}return this}addQuadraticCurveTo(t,s,e,i,a=36){if(this.closed)return this;let h=(n,r,c,l)=>(1-n)*(1-n)*r+2*n*(1-n)*c+n*n*l,o=this._points[this._points.length-1];for(let n=0;n<=a;n++){let r=n/a,c=h(r,o.x,t,e),l=h(r,o.y,s,i);this.addLineTo(c,l)}return this}addBezierCurveTo(t,s,e,i,a,h,o=36){if(this.closed)return this;let n=(c,l,p,g,m)=>(1-c)*(1-c)*(1-c)*l+3*c*(1-c)*(1-c)*p+3*c*c*(1-c)*g+c*c*c*m,r=this._points[this._points.length-1];for(let c=0;c<=o;c++){let l=c/o,p=n(l,r.x,t,e,a),g=n(l,r.y,s,i,h);this.addLineTo(p,g)}return this}isPointInside(t){let s=!1,e=this._points.length;for(let i=e-1,a=0;a<e;i=a++){let h=this._points[i],o=this._points[a],n=o.x-h.x,r=o.y-h.y;if(Math.abs(r)>Number.EPSILON){if(r<0&&(h=this._points[a],n=-n,o=this._points[i],r=-r),t.y<h.y||t.y>o.y)continue;if(t.y===h.y&&t.x===h.x)return!0;{let c=r*(t.x-h.x)-n*(t.y-h.y);if(c===0)return!0;if(c<0)continue;s=!s}}else{if(t.y!==h.y)continue;if(o.x<=t.x&&t.x<=h.x||h.x<=t.x&&t.x<=o.x)return!0}}return s}close(){return this.closed=!0,this}length(){let t=this._length;if(this.closed){let s=this._points[this._points.length-1],e=this._points[0];t+=e.subtract(s).length()}return t}area(){let t=this._points.length,s=0;for(let e=t-1,i=0;i<t;e=i++)s+=this._points[e].x*this._points[i].y-this._points[i].x*this._points[e].y;return s*.5}getPoints(){return this._points}getPointAtLengthPosition(t){if(t<0||t>1)return d.Zero();let s=t*this.length(),e=0;for(let i=0;i<this._points.length;i++){let a=(i+1)%this._points.length,h=this._points[i],n=this._points[a].subtract(h),r=n.length()+e;if(s>=e&&s<=r){let c=n.normalize(),l=s-e;return new d(h.x+c.x*l,h.y+c.y*l)}e=r}return d.Zero()}static StartingAt(t,s){return new _(t,s)}},R=class _{constructor(t,s=null,e,i=!1){this.path=t,this._curve=new Array,this._distances=new Array,this._tangents=new Array,this._normals=new Array,this._binormals=new Array,this._pointAtData={id:0,point:u.Zero(),previousPointArrayIndex:0,position:0,subPosition:0,interpolateReady:!1,interpolationMatrix:I.Identity()};for(let a=0;a<t.length;a++)this._curve[a]=t[a].clone();this._raw=e||!1,this._alignTangentsWithPath=i,this._compute(s,i)}getCurve(){return this._curve}getPoints(){return this._curve}length(){return this._distances[this._distances.length-1]}getTangents(){return this._tangents}getNormals(){return this._normals}getBinormals(){return this._binormals}getDistances(){return this._distances}getPointAt(t){return this._updatePointAtData(t).point}getTangentAt(t,s=!1){return this._updatePointAtData(t,s),s?u.TransformCoordinates(u.Forward(),this._pointAtData.interpolationMatrix):this._tangents[this._pointAtData.previousPointArrayIndex]}getNormalAt(t,s=!1){return this._updatePointAtData(t,s),s?u.TransformCoordinates(u.Right(),this._pointAtData.interpolationMatrix):this._normals[this._pointAtData.previousPointArrayIndex]}getBinormalAt(t,s=!1){return this._updatePointAtData(t,s),s?u.TransformCoordinates(u.UpReadOnly,this._pointAtData.interpolationMatrix):this._binormals[this._pointAtData.previousPointArrayIndex]}getDistanceAt(t){return this.length()*t}getPreviousPointIndexAt(t){return this._updatePointAtData(t),this._pointAtData.previousPointArrayIndex}getSubPositionAt(t){return this._updatePointAtData(t),this._pointAtData.subPosition}getClosestPositionTo(t){let s=Number.MAX_VALUE,e=0;for(let i=0;i<this._curve.length-1;i++){let a=this._curve[i+0],h=this._curve[i+1].subtract(a).normalize(),o=this._distances[i+1]-this._distances[i+0],n=Math.min(Math.max(u.Dot(h,t.subtract(a).normalize()),0)*u.Distance(a,t)/o,1),r=u.Distance(a.add(h.scale(n*o)),t);r<s&&(s=r,e=(this._distances[i+0]+o*n)/this.length())}return e}slice(t=0,s=1){if(t<0&&(t=1-t*-1%1),s<0&&(s=1-s*-1%1),t>s){let r=t;t=s,s=r}let e=this.getCurve(),i=this.getPointAt(t),a=this.getPreviousPointIndexAt(t),h=this.getPointAt(s),o=this.getPreviousPointIndexAt(s)+1,n=[];return t!==0&&(a++,n.push(i)),n.push(...e.slice(a,o)),(s!==1||t===1)&&n.push(h),new _(n,this.getNormalAt(t),this._raw,this._alignTangentsWithPath)}update(t,s=null,e=!1){for(let i=0;i<t.length;i++)this._curve[i].x=t[i].x,this._curve[i].y=t[i].y,this._curve[i].z=t[i].z;return this._compute(s,e),this}_compute(t,s=!1){let e=this._curve.length;if(e<2)return;this._tangents[0]=this._getFirstNonNullVector(0),this._raw||this._tangents[0].normalize(),this._tangents[e-1]=this._curve[e-1].subtract(this._curve[e-2]),this._raw||this._tangents[e-1].normalize();let i=this._tangents[0],a=this._normalVector(i,t);this._normals[0]=a,this._raw||this._normals[0].normalize(),this._binormals[0]=u.Cross(i,this._normals[0]),this._raw||this._binormals[0].normalize(),this._distances[0]=0;let h,o,n,r,c;for(let l=1;l<e;l++)h=this._getLastNonNullVector(l),l<e-1&&(o=this._getFirstNonNullVector(l),this._tangents[l]=s?o:h.add(o),this._tangents[l].normalize()),this._distances[l]=this._distances[l-1]+this._curve[l].subtract(this._curve[l-1]).length(),n=this._tangents[l],c=this._binormals[l-1],this._normals[l]=u.Cross(c,n),this._raw||(this._normals[l].length()===0?(r=this._normals[l-1],this._normals[l]=r.clone()):this._normals[l].normalize()),this._binormals[l]=u.Cross(n,this._normals[l]),this._raw||this._binormals[l].normalize();this._pointAtData.id=NaN}_getFirstNonNullVector(t){let s=1,e=this._curve[t+s].subtract(this._curve[t]);for(;e.length()===0&&t+s+1<this._curve.length;)s++,e=this._curve[t+s].subtract(this._curve[t]);return e}_getLastNonNullVector(t){let s=1,e=this._curve[t].subtract(this._curve[t-s]);for(;e.length()===0&&t>s+1;)s++,e=this._curve[t].subtract(this._curve[t-s]);return e}_normalVector(t,s){let e,i=t.length();if(i===0&&(i=1),s==null){let a;P(Math.abs(t.y)/i,1,w)?P(Math.abs(t.x)/i,1,w)?P(Math.abs(t.z)/i,1,w)?a=u.Zero():a=new u(0,0,1):a=new u(1,0,0):a=new u(0,-1,0),e=u.Cross(t,a)}else e=u.Cross(t,s),u.CrossToRef(e,t,e);return e.normalize(),e}_updatePointAtData(t,s=!1){if(this._pointAtData.id===t)return this._pointAtData.interpolateReady||this._updateInterpolationMatrix(),this._pointAtData;this._pointAtData.id=t;let e=this.getPoints();if(t<=0)return this._setPointAtData(0,0,e[0],0,s);if(t>=1)return this._setPointAtData(1,1,e[e.length-1],e.length-1,s);let i=e[0],a,h=0,o=t*this.length();for(let n=1;n<e.length;n++){a=e[n];let r=u.Distance(i,a);if(h+=r,h===o)return this._setPointAtData(t,1,a,n,s);if(h>o){let l=(h-o)/r,p=i.subtract(a),g=a.add(p.scaleInPlace(l));return this._setPointAtData(t,1-l,g,n-1,s)}i=a}return this._pointAtData}_setPointAtData(t,s,e,i,a){return this._pointAtData.point=e,this._pointAtData.position=t,this._pointAtData.subPosition=s,this._pointAtData.previousPointArrayIndex=i,this._pointAtData.interpolateReady=a,a&&this._updateInterpolationMatrix(),this._pointAtData}_updateInterpolationMatrix(){this._pointAtData.interpolationMatrix=I.Identity();let t=this._pointAtData.previousPointArrayIndex;if(t!==this._tangents.length-1){let s=t+1,e=this._tangents[t].clone(),i=this._normals[t].clone(),a=this._binormals[t].clone(),h=this._tangents[s].clone(),o=this._normals[s].clone(),n=this._binormals[s].clone(),r=D.RotationQuaternionFromAxis(i,a,e),c=D.RotationQuaternionFromAxis(o,n,h);D.Slerp(r,c,this._pointAtData.subPosition).toRotationMatrix(this._pointAtData.interpolationMatrix)}}},S=class _{static CreateQuadraticBezier(t,s,e,i){i=i>2?i:3;let a=[],h=(o,n,r,c)=>(1-o)*(1-o)*n+2*o*(1-o)*r+o*o*c;for(let o=0;o<=i;o++)a.push(new u(h(o/i,t.x,s.x,e.x),h(o/i,t.y,s.y,e.y),h(o/i,t.z,s.z,e.z)));return new _(a)}static CreateCubicBezier(t,s,e,i,a){a=a>3?a:4;let h=[],o=(n,r,c,l,p)=>(1-n)*(1-n)*(1-n)*r+3*n*(1-n)*(1-n)*c+3*n*n*(1-n)*l+n*n*n*p;for(let n=0;n<=a;n++)h.push(new u(o(n/a,t.x,s.x,e.x,i.x),o(n/a,t.y,s.y,e.y,i.y),o(n/a,t.z,s.z,e.z,i.z)));return new _(h)}static CreateHermiteSpline(t,s,e,i,a){let h=[],o=1/a;for(let n=0;n<=a;n++)h.push(u.Hermite(t,s,e,i,n*o));return new _(h)}static CreateCatmullRomSpline(t,s,e){let i=[],a=1/s,h=0;if(e){let o=t.length;for(let n=0;n<o;n++){h=0;for(let r=0;r<s;r++)i.push(u.CatmullRom(t[n%o],t[(n+1)%o],t[(n+2)%o],t[(n+3)%o],h)),h+=a}i.push(i[0])}else{let o=[];o.push(t[0].clone()),Array.prototype.push.apply(o,t),o.push(t[t.length-1].clone());let n=0;for(;n<o.length-3;n++){h=0;for(let r=0;r<s;r++)i.push(u.CatmullRom(o[n],o[n+1],o[n+2],o[n+3],h)),h+=a}n--,i.push(u.CatmullRom(o[n],o[n+1],o[n+2],o[n+3],h))}return new _(i)}static ArcThru3Points(t,s,e,i=32,a=!1,h=!1){let o=[],n=s.subtract(t),r=e.subtract(s),c=t.subtract(e),l=u.Cross(n,r),p=l.length();if(p<Math.pow(10,-8))return new _(o);let g=n.lengthSquared(),m=r.lengthSquared(),z=c.lengthSquared(),M=l.lengthSquared(),F=n.length(),E=r.length(),W=c.length(),x=.5*F*E*W/p,B=u.Dot(n,c),Q=u.Dot(n,r),Z=u.Dot(r,c),H=-.5*m*B/M,U=-.5*z*Q/M,j=-.5*g*Z/M,b=t.scale(H).add(s.scale(U)).add(e.scale(j)),C=t.subtract(b).normalize(),q=u.Cross(l,C).normalize();if(h){let y=2*Math.PI/i;for(let f=0;f<=2*Math.PI;f+=y)o.push(b.add(C.scale(x*Math.cos(f)).add(q.scale(x*Math.sin(f)))));o.push(t)}else{let y=1/i,f=0,v=u.Zero();do v=b.add(C.scale(x*Math.cos(f)).add(q.scale(x*Math.sin(f)))),o.push(v),f+=y;while(!v.equalsWithEpsilon(e,x*y*1.1));o.push(e),a&&o.push(t)}return new _(o)}constructor(t){this._length=0,this._points=t,this._length=this._computeLength(t)}getPoints(){return this._points}length(){return this._length}continue(t){let s=this._points[this._points.length-1],e=this._points.slice(),i=t.getPoints();for(let h=1;h<i.length;h++)e.push(i[h].subtract(i[0]).add(s));return new _(e)}_computeLength(t){let s=0;for(let e=1;e<t.length;e++)s+=t[e].subtract(t[e-1]).length();return s}};export{N as a,V as b,R as c,S as d};
