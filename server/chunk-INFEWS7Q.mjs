import './polyfills.server.mjs';
import{t as u,u as r}from"./chunk-KTHBQP3E.mjs";import{a as e}from"./chunk-JBXNSZOT.mjs";var i=class extends u{constructor(){super(...arguments),this.priority=0}_isSingularConnection(){return!1}connectTo(n){super.connectTo(n),this._connectedPoint.sort((t,s)=>s.priority-t.priority)}_activateSignal(n){if(n.logger?.addLogItem({action:"ActivateSignal",className:this._ownerBlock.getClassName(),uniqueId:this._ownerBlock.uniqueId,payload:{connectionType:this.connectionType,name:this.name}}),this.connectionType===0)n._notifyExecuteNode(this._ownerBlock),this._ownerBlock._execute(n,this),n._increaseExecutionId();else for(let t of this._connectedPoint)t._activateSignal(n)}};e("FlowGraphSignalConnection",i);var o=class extends r{constructor(n){super(n),this.priority=0,this.signalInputs=[],this.signalOutputs=[],this.in=this._registerSignalInput("in"),this.error=this._registerSignalOutput("error")}_registerSignalInput(n){let t=new i(n,0,this);return this.signalInputs.push(t),t}_registerSignalOutput(n){let t=new i(n,1,this);return this.signalOutputs.push(t),t}_unregisterSignalInput(n){let t=this.signalInputs.findIndex(s=>s.name===n);t!==-1&&(this.signalInputs[t].dispose(),this.signalInputs.splice(t,1))}_unregisterSignalOutput(n){let t=this.signalOutputs.findIndex(s=>s.name===n);t!==-1&&(this.signalOutputs[t].dispose(),this.signalOutputs.splice(t,1))}_reportError(n,t){this.error.payload=typeof t=="string"?new Error(t):t,this.error._activateSignal(n)}getSignalInput(n){return this.signalInputs.find(t=>t.name===n)}getSignalOutput(n){return this.signalOutputs.find(t=>t.name===n)}serialize(n={}){super.serialize(n),n.signalInputs=[],n.signalOutputs=[];for(let t of this.signalInputs){let s={};t.serialize(s),n.signalInputs.push(s)}for(let t of this.signalOutputs){let s={};t.serialize(s),n.signalOutputs.push(s)}}deserialize(n){for(let t=0;t<n.signalInputs.length;t++){let s=this.getSignalInput(n.signalInputs[t].name);if(s)s.deserialize(n.signalInputs[t]);else throw new Error("Could not find signal input with name "+n.signalInputs[t].name+" in block "+n.className)}for(let t=0;t<n.signalOutputs.length;t++){let s=this.getSignalOutput(n.signalOutputs[t].name);if(s)s.deserialize(n.signalOutputs[t]);else throw new Error("Could not find signal output with name "+n.signalOutputs[t].name+" in block "+n.className)}}getClassName(){return"FlowGraphExecutionBlock"}};export{o as a};
